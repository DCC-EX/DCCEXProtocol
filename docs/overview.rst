.. include:: /include/include.rst

Library Design Principles
=========================

.. sidebar:: 

  .. contents:: On this page
    :depth: 2
    :local:

First of all, this library implements the DCC-EX Native protocol in a non-blocking fashion. After creating a DCCEXProtocol object, you set up various necessities such as the network connection and a debug console.

Then, you call the ```check()``` method as often as you can (ideally, once per invocation of the ```loop()``` method) and the library will manage the I/O stream, reading in/parsing commands and calling methods on the delegate as information is available.

These patterns (Dependency Injection and Delegation) allow you to keep the different parts of your sketch from becoming too intertwined with each other. Nothing in the code that manages the pushbuttons or speed knobs needs to have any detailed knowledge of the |EX-NCP|.

DCCEXProtocol Class
-------------------

The `DCCEXProtocol` class manages all relevant objects advertised by a |DCC-EX| |EX-CS| and exposes simple methods to control these objects from the client software.

These objects include:

- Roster entries
- Route entries
- Turnouts
- Turntables (noting that these objects are only available in development versions)

This means the client software does not need to explicitly manage the state of these objects whilever the ```check()``` method mentioned above is called appropriately.

DCCEXProtocolDelegate Class
---------------------------

The `DCCEXProtocolDelegate` class enables the client software to respond to various events generated by a |DCC-EX| |EX-CS| as either broadcasts or responses to commands.

The events able to be managed via this class are over and above those managed by the `DCCEXProtocol` class and are entirely customisable by the client software to provide dynamic user experience updates such as displaying status changes to objects as they are broadcast from the |DCC-EX| |EX-CS|.

