
# Credits

The delegate and connection code in this library is taken directly from the WiThrottle library by **Copyright Â© 2018-2019 Blue Knobby Systems Inc.**
The rest of the code has been developed by Peter Akers (Flash62au), Peter Cole (peteGSX), and Chris Harlow (UKBloke).

----

# DCC-EX Native command protocol library

This library implements the DCC-EX Native command protocol (as used in EX-CommandStation ONLY), allowing a device to connect to the server and act as a client (such as a hardware based throttle).

The implementation of this library is tested on ESP32 based devices running the Arduino framework. There's nothing in here that's specific to the ESP32, and little of Arduino that couldn't be replaced as needed.

There has also been limited testing on STM32F103C8 Bluepill.

## Basic Design Principles

First of all, this library implements the DCC-EX Native protocol in a non-blocking fashion. After creating a DCCEXProtocol object, you set up various necessities such as the network connection and a debug console (see [Dependency Injection][depinj]).

Then, you call the ```check()``` method as often as you can (ideally, once per invocation of the ```loop()``` method) and the library will manage the I/O stream, reading in/parsing commands and calling methods on the [delegate] as information is available.

These patterns (Dependency Injection and Delegation) allow you to keep the different parts of your sketch from becoming too intertwined with each other. Nothing in the code that manages the pushbuttons or speed knobs needs to have any detailed knowledge of the DCC-EX native protocol.

### DCCEXProtocol Class

Full documentation of the classes is available via the [DCC-EX website](file:///C:/Code/DCCEXProtocol/docs/_build/html/index.html).

The DCCEXProtocol class manages all relevant objects advertised by a DCC-EX EX-CommandStation and exposes simple methods to control these objects from the client software.

These objects include:

- Roster entries
- Route entries
- Turnouts
- Turntables (noting that these objects are only available in development versions)

This means the client software does not need to explicitly manage the state of these objects whilever the ```check()``` method mentioned above is called appropriately.

### DCCEXProtocolDelegate Class

The DCCEXProtocolDelegate class enables the client software to respond to various events generated by a DCC-EX EX-CommandStation as either broadcasts or responses to commands.

The events able to be managed via this class are over and above those managed by the DCCEXProtocol class and are entirely customisable by the client software to provide dynamic user experience updates such as displaying status changes to objects as they are broadcast from the DCC-EX EX-CommandStation.

## Included examples

Note that all included examples use WiFi, but the protocol is equally suited to other connection types utilising the Arduino Stream base class including Ethernet and Serial.

### DCCEXProtocol_Basic

Basic example to implement a DCCEXProtocol client and connect to a server (with static IP).

Change the WiFi settings and enter the IP address of the Arduino running EX-CommandStation:

``` cpp
const char* ssid = "MySSID";
const char* password =  "MyPWD";
IPAddress serverAddress(192,168,1,1);
```

Compile and run, you should see the client connect in the Serial monitor.

### DCCEX_Delegate

Example to show how to implement a delegate class to handle callbacks.

Compile and run, you should see in the Serial monitor the server version printed.

### DCCEXProtocol_Roster_etc

Example to show how to retrieve the Roster, Turnouts/Point list, Routes/Automations List, and Turntable List for the Server.

Compile and run, you should see in the Serial monitor the lists printed.

### DCCEXProtocol_Loco_Control

Example to show how to acquire and control locos. The Example assumes that you have a Roster on the EX-CommandStation with at least two entries.

Compile and run, you should see in the Serial monitor, after 20 second delays, two locos on two throttles change speed, and have functions randomly change.

----

# Usage

## Throttles

To simplify the handling of Consists/Multiple Unit Trains the library is implemented to behave in a similar manner to the WiThrottle(TM) protocol, in that it *requires* that locos are attached to a 'throttle'.

The protocol provides for the throttle app to specify the number of throttles required ```DCCEXProtocol(int maxThrottles=6, bool server=false);```

For simple applications controlling a single loco, this adds a small amount of overhead, but the cons of this small overhead are far outweighed by the benefits of being able to manage multiple locos as consists without needing to program CVs every time you wish to assemble a consist (although speed matching is still obviously required).

To acquire a loco on throttle 0 (zero) (the first throttle), you must specify a DDC address or a loco from the roster.

From a DCC Address:

```dccexProtocol.throttle[0].addFromEntry(11, FacingForward);``` will add a loco with a DCC address of 11 on throttle 0, facing forward.

From a Roster Entry:

To add the loco to the throttle use ```dccexProtocol.throttle[0].addFromRoster(dccexProtocol.getRosterEntryNo(1), FacingForward);``` to add a loco to Throttle 0, facing forward.

Control the speed and direction of all the locos on Throttle 0 with ```dccexProtocol.sendThrottleAction(0, speed, Forward);```

## Rosters

The Roster is stored as a Linked List.

Retrieve the list with ```dccexProtocol.getRoster();```

Or with ```dccexProtocol.getLists(bool rosterRequired, bool turnoutListRequired, bool routeListRequired, bool turntableListRequired);```

The roster has been fully received when ```isRosterFullyReceived()``` is true.

Retrieve the size of the list (number of locos) with ```dccexProtocol.getRosterCount()```

Retrieve a ```Loco*``` object from the list with ```dccexProtocol.getRosterEntryNo(listEntryNumber)```

## Turnouts/Points

The List of defined Turnouts/Points is stored as a Linked List.

Retrieve the list with ```dccexProtocol.getTurnouts();```

Or with ```dccexProtocol.getLists(bool rosterRequired, bool turnoutListRequired, bool routeListRequired, bool turntableListRequired);```

The list has been fully received when ```isTurnoutListFullyReceived()``` is true.

Retrieve the size of the list with ```dccexProtocol.getTurnoutsCount()```

Retrieve a ```Turnout*``` object from the list with ```dccexProtocol.getTurnoutsEntryNo(listEntryNumber)```

## Routes/Automations

The List of defined Routes/Automations is stored as a Linked List.

Retrieve the list with ```dccexProtocol.getRoutes();```

Or with ```dccexProtocol.getLists(bool rosterRequired, bool turnoutListRequired, bool routeListRequired, bool turntableListRequired);```

The list has been fully received when ```isRouteListFullyReceived()``` is true.

Retrieve the size of the list with ```dccexProtocol.getRoutesCount()```

Retrieve a ```Route*``` object from the list with ```dccexProtocol.getRoutesEntryNo(listEntryNumber)```

## Turntables

The List of defined Turntables is stored as a Linked List.

Retrieve the list with ```dccexProtocol.getTurntables();```

Or with ```dccexProtocol.getLists(bool rosterRequired, bool turnoutListRequired, bool routeListRequired, bool turntableListRequired);```

The list has been fully received when ```isTurntableListFullyReceived()``` is true.

Retrieve the size of the list with ```dccexProtocol.getTurntablesCount()```

Retrieve a ```Turntable*``` object from the list with ```dccexProtocol.getTurntablesEntryNo(listEntryNumber)```

----

# Documentation

Documentation of the DCCEXProtocol library is available via the [DCC-EX website](file:///C:/Code/DCCEXProtocol/docs/_build/html/index.html).

For contributors wishing to build local copies of the documentation while updating the library, here is the very high level process of the requirements to make this work on Windows:

- Install [MSYS2 C++](https://code.visualstudio.com/docs/cpp/config-mingw#_prerequisites) compilers
- Install [CMake](https://cmake.org/download/) and ensure you select the option to add to your user path
- Install [Doxygen](https://www.doxygen.nl/download.html) and once complete, add to your user path
- Install the CMake Tools extension in VSCode
- Setup a Python virtual environment with "virtualenv venv" and activate with "venv\scripts\activate"
- Install required Python modules with "pip3 install -r requirements.txt"
- Change to the docs directory and run "make html"

----

# License

Creative Commons [CC-BY-SA 4.0][CCBYSA]   ![CCBYSA](https://i.creativecommons.org/l/by-sa/4.0/88x31.png)

**Free Software, Oh Yeah!**

[//]: # (These are reference links used in the body of this note and get stripped out when the markdown processor does its job. There is no need to format nicely because it shouldn't be seen. Thanks SO - http://stackoverflow.com/questions/4823468/store-comments-in-markdown-syntax)

   [depinj]: <https://en.wikipedia.org/wiki/Dependency_injection>
   [delegate]: <https://en.wikipedia.org/wiki/Delegation_(object-oriented_programming)>
   [CCBYSA]: <http://creativecommons.org/licenses/by-sa/4.0/>
